// Q-1 What is the worst-case time complexity of linear search algorithm??

// A) O(n^2)
// B) O(1)
// C) O(n/2)
// D) O(n)

// Res: D) O(n)
// Reason: Linearly search of elements (from left to right of array) one by one using linear search algorithm.

// Q-2 Binary search can work on unsorted data too

// A) True
// B) False

// Res: B) False
// Reason: Binary search can only work on sorted data (array).

// Q-3 What is the complexity of BINARY SEARCH?

// A) O(log N base 2)
// B) O(log N base 3)
// C) O(log N^2)
// D) O(log N/2)

// Res: A) O(log N base 2)
// Reason: Order of logarithm N to base 2 is equal to K where N is the number of elements in array & K is the number of comparisons/divisions by divide & conquer rule.

// Q-4 Bubble sort is based on the idea of repeatedly comparing pairs of first and last elements and then swapping their positions if they exist in the wrong order.

// A) True
// B) False

// Res: B) False
// Reason:

// Q-5 Worst case time complexity of BUBBLE sort is:

// A) O(n^2)
// B) O(log n)
// C) O(n)
// D) O(1)

// Res: A) O(n^2)
// Reason:

// Q-6 Insertion sort is based on the idea that one element from the input elements is consumed in each iteration to find its correct position i.e, the position to which it belongs in a sorted array.

// A) True
// B) False

// Res: A) True
// Reason:

// Q-7 Worst-case time complexity of INSERTION sort?
// A) O(n^2)
// B) O(log n)
// C) O(n)
// D) O(1)

// Res: A) O(n^2)
// Reason:

// Q-8 The Selection sort algorithm is based on the idea of finding the minimum or maximum element in an unsorted array and then putting it at the end.

// A) True
// B) False

// Res: B) False
// Reason: The Selection sort algorithm is based on the idea of finding the minimum element in an unsorted array and then putting it at the start.

// Q-9 The worst-case time complexity of SELECTION sort?

// A) O(n^2)
// B) O(log n)
// C) O(n)
// D) O(1)

// Res: A) O(n^2)
// Reason:

// Q-10: What is the maximum number of comparisons done in Binary search for 100,000 elements.

// A) 16
// B) 100000
// C) 512
// D) 1024

// Res: A) 16
// Reason: log to base 2 of 100000 = 16.6096.... = 16
